<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width, user-scalable=yes, minimum-scale=1.0, maximum-scale=2.0">

<title>
  
    
  Synthesizer - Clock module | rabid.audio
  
</title>

<meta name="description" content="Documenting my work at the intersection of technology and music."/>
<link rel="me" href="https://cathode.church/@julien"/>

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cutive+Mono&family=Oxygen&display=swap" rel="stylesheet">

<link rel="stylesheet" href="/_bridgetown/static/index.GCL2Q73U.css"/>
<script src="/_bridgetown/static/index.LQD2JBNB.js" defer></script>

  </head>
  <body class="default ">
    <header><a href="/">
    <h1 class="logo">rabid.audio</h1>
  </a>
  <p class="tagline">Documenting my work at the intersection of technology and music.</p>

  <nav>
    <ul>
      <li>
        <a href="/">Home</a>
      </li><li>
        <a href="/posts">Posts</a>
      </li>
      <li>
        <a href="/resources">Resources</a>
      </li><li>
        <a href="/links">Links</a>
      </li>
    </ul>
  </nav>
</header>

    <main>
      
        <h1>Synthesizer - Clock module</h1>
      
      <p>This is a clock Eurorack synth module designed to drive sequencers, drum machines, arpeggiators, etc.</p>

<p>It’s entirely digital, which makes it an easier module to build since most of the complexity is in software.</p>

<h2 id="source">Source</h2>

<p>Source files including code and CAD are available on <a href="https://github.com/rabidaudio/synthesizer/tree/master/clock">GitHub</a>. Like most everything I do, this is <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">open hardware</a>.</p>

<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="Creative Commons License" /></p>

<h2 id="status">Status</h2>

<p>In development. Working on a breadboard, most features software features have been implemented. PCB designed and ordered, awaiting fab.</p>

<h3 id="todo">TODO</h3>

<ul>
  <li>Assemble and verify PCB</li>
  <li>Fix software</li>
  <li>Design panel cuts and decals</li>
  <li>Assemble PCB and verify</li>
  <li>Cut and decal panel</li>
</ul>

<h2 id="features">Features</h2>

<ul>
  <li>15 to 300 BPM</li>
  <li>Tap-tempo input</li>
  <li>CV input for controlling clock speed</li>
  <li>Swing control, up to triplets leading or lagging</li>
  <li>A separate subdivision output which can trigger at an integer multiple of the clock speed</li>
  <li>Efficient 3HP size</li>
</ul>

<h3 id="future-features">Future features</h3>

<ul>
  <li>“negative” subdivisions</li>
  <li>remember BPM setting between power cycles</li>
  <li>start/stop/restart</li>
</ul>

<h2 id="usage">Usage</h2>

<ul>
  <li>Turn the knob to control the BPM. LEDs display the current BPM, and decimal points blink with the outputs.</li>
  <li>Apply a unipolar voltage from 0-5V to the CV input to adjust the clock speed. 0V is no additional increase in rate over the knob setting. Each 1V is 64 additional BPM, capped at 300 BPM.</li>
  <li>Tap the knob button two or more times to set the BPM through tap-tempo. This effects the base BPM before the CV is applied.</li>
  <li>Hold the subdivision button and turn the knob to control the subdivisions. LEDs display the subdivision setting.</li>
  <li>Hold the swing button and turn the knob to control the amount of swing. LEDs display the swing amount from -127 to 127.</li>
  <li>Press both the subdivision button and swing button at the same time to reset the subdivision counter and pause the clock. LEDs display <code class="highlighter-rouge">000</code>.</li>
  <li>Hold both the subdivision button and swing button at the same time for 2 seconds to perform a factory reset, returning the BPM, subdivision, and swing settings to the defaults.</li>
</ul>

<h2 id="design">Design</h2>

<div class="image-container full"><img src="/images/clock_schematic.png" /></div>

<p>The <a href="/resources#ATMega328P">ATMega328P</a> is used as the core microprocessor. Originally I planned on using the <a href="/resources#ATTiny85">ATTiny85</a> with an <a href="resources#HT16K33">HT16K33</a> LED driver, but there were just enough available pins on the Mega to drive the 7-segment displays directly, and the availability of a 16-bit timer drastically improves the resolution of the clock.</p>

<p>An ISP header allows reprogramming of the firmware using any AVR programmer.</p>

<p>The code uses <a href="https://platformio.org/">PlatformIO</a> for build tooling. Separate C++ classes encapsulate logic of each of the components, using header-only files to simplify file structure.</p>

<p>This is a relatively simple module, all digital module with most of the logic in code. However much of the complexity comes from targeting a 3HP size. 1HP is only 5.08mm wide, so we’re working with effectively 15mm of horizontal space. Some weird schematic wiring and pin assignments is done to simplify PCB routes.</p>

<h3 id="timer">Timer</h3>

<p><code class="highlighter-rouge">Timer1</code> is a 16-bit timer which is used as the clock core. This way the main loop is free to focus on user input without worrying about timing or performance; <code class="highlighter-rouge">Timer1</code> will interrupt when it’s time to trigger a clock signal. It counts from 0 up to the value in register <code class="highlighter-rouge">OCR1A</code>, at which point an interrupt is issued and the timer restarts. We bring the clock pin high when the timer is at 0. We use <code class="highlighter-rouge">OCR1B</code> as a second interrupt at 313 to bring the clock signal low again, creating a fixed pulse width of 20ms.</p>

<p>The formula for timer frequency is <code class="highlighter-rouge">16_000_000/((OCR1A+1)*1024)</code> where <code class="highlighter-rouge">16_000_000</code> represents the the 16MHz system clock of the ATMega and <code class="highlighter-rouge">1024</code> is the pre-scaler setting For a 16-bit timer this gives a possible frequency range from 5208 Hz to 0.238Hz. See <a href="/resources#ATMega328P">the datasheet</a> for a more thorough explanation of AVR timers.</p>

<p>Rather than doing this heavy floating-point math on-device, these were <a href="https://docs.google.com/spreadsheets/d/e/2PACX-1vRYF0LwfJ1-PHLnWnM49WWA0hqCR1MDAl3SorFMbPlyfnnnua1AY_6QSFmG-xYukErxw6XOodOVI3JO/pubhtml">pre-generated</a> and loaded into flash as a lookup table.</p>

<p>The timer has a maximum error of 0.06% for pulses less than 5 Hz (300 BPM) and less than 0.25% for the maximum pulse rate of 20 Hz.</p>

<div class="image-container big center"><img src="/images/clock_module_bpm_error.png" /></div>

<p><a href="https://en.wikipedia.org/wiki/Swing_(jazz_performance_style)">Swing</a> works by alternating each beat between two different timer values. These timer values average to the base clock frequency, but their ratio is controlled by the swing value. At <code class="highlighter-rouge">0</code>, the beats are even and there is no swing. At maximum value the swing beats are triplets.</p>

<!-- TODO: subdivisions -->

<h3 id="leds">LEDs</h3>

<p>Most 7 segment displays are quite large, too large for our 3HP form factor. However I was able to find some <a href="/resources#SM460281N">10mm wide 7-segment displays</a> from China. One quirk is despite clearly having a decimal LED, there’s no pin exposed for it; just the 7 main segments and the common cathode.</p>

<p>Rather than drive all <code class="highlighter-rouge">7*3 = 21</code> LEDs at the same time, the microprocessor steps through each display one at a time and sets the character for that display. Not only does this reduce the number of pins required (to <code class="highlighter-rouge">7 + number_of_displays</code>), it also uses less
power.</p>

<p>The common cathode for the selected display is pulled low, while the common cathode for the other displays remain high. The microprocessor round-robins through each display approximately every 1ms, which is fast enough that our eyes perceive this as a reduction in brightness rather than a blink. With three displays, each display is on 1/3 of the time, cutting the brightness to 33.3%. At higher numbers of displays this solution would start to break down as the brightness would become too low, but for this application it works quite well.</p>

<p>To display a character, each of the 7 segments is controlled by one pin. To optimize performance, all 7 displays are put on the same PORT (in this case <code class="highlighter-rouge">PORTF</code>) allowing them to be controlled via a single register and therefore set in a single instruction. Every supported character has a 7-bit bit mask that indicates which segments are on or off. For example:</p>

<p><img src="/images/7segment-names.png" alt="segment names" /></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                   <span class="c1">//_ABCDEGF</span>
<span class="cp">#define EIGHT      0b01111111 // all the segments on
#define SPACE      0b00000000 // all the segments off
#define ONE        0b00110000
#define UNDERSCORE 0b00001000
</span>
<span class="kt">void</span> <span class="nf">write</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">bitmask</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// We're only using 7 LS bits for controlling</span>
  <span class="c1">// the display, the last bit may be used as another</span>
  <span class="c1">// IO, so we don't want to overwrite it.</span>
  <span class="o">*</span><span class="n">_segmentPort</span> <span class="o">=</span> <span class="p">(</span><span class="n">bitmask</span> <span class="o">&amp;</span> <span class="mb">0b01111111</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">*</span><span class="n">_segmentPort</span> <span class="o">&amp;</span> <span class="mb">0b10000000</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="knob">Knob</h3>

<p>Rather than a potentiometer, the knob control is a <a href="/resources#PEC11R">24-detent rotary encoder</a>. <a href="https://www.electrosoftcloud.com/en/pcint-interrupts-on-arduino/">Pin-control interrupts</a> (<code class="highlighter-rouge">PCINT</code>) detect rotations and keep track of the number of steps. Then the main logic loop polls this and adjusts the parameter as necessary. <a href="https://www.youtube.com/watch?v=v4BbSzJ-hz4">This video</a> is pretty good at explaining how a rotary encoder works.</p>

<h3 id="power-supply">Power supply</h3>

<p>While the Eurorack power connector has a 5V power supply line, in this module I’m using the 12V supply line and an <a href="/resources#LM7805">L7805</a> to regulate the 12V line to 5V. The reason for this is the high current requirements of the display. Most Eurorack power supplies have a lot more current available on the +12V line than on the 5V and -12V lines.</p>

<p>These LEDs have a forward voltage drop of ~2V. With a 1Kohm current limiting resistor, that means each LED is driven with <code class="highlighter-rouge">(5V-2V)/1Kohm = 3mA</code>. There are two additional LEDs that blink with the outputs. That means even with only one display on at a time the LEDs alone require up to <code class="highlighter-rouge">9 * 3mA = 27mA</code> at any given time, and that’s before factoring in the microprocessor, which is another 10-15mA.</p>

<h3 id="cv-input">CV input</h3>

<p>This is a digital circuit operating at 5V, but in Eurorack world CV lines are often -10V to 10V. We need to protect our precious microprocessor against a user mistakenly applying a high (or low) voltage to the CV input.</p>

<p>For more precision we could use an op-amp, but here the requirements are minimal and the space is tight, so I opted for a much simpler solution: a diode and voltage divider (D3, R14, R15). The diode protects from negative CV inputs by ensuring the CV is always forward biased. The CV input is unipolar, but if you apply a bipolar CV, the negative components will be treated as 0, no change in tempo. This does effect the bounds slightly, as to overcome the diode, the CV needs to be at least ~1V. However, you can easily tune the base BPM or CV input to account for this.</p>

<p>To protect against voltages of greater than 5V, a simple voltage divider is used. The voltage is scaled by <code class="highlighter-rouge">100Kohm/(100Kohm + 180Kohm) = ~36%</code>. Thus if you apply the +12V rail to the CV in (the hypothetical highest voltage available in a Eurorack system), the microprocessor’s analog input will see 4.39V, comfortably below the 5V supply range.</p>

<!-- LPF? -->
<!-- older rotary encoder designs? -->
<!-- backpack and switching? -->

    </main>

    <footer><div class="blurb"><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-SA</a>.</div>
  <div class="blurb">Last Updated <a href="https://github.com/rabidaudio/rabid.audio">2023-03-12</a>.</div>
  <div class="blurb">Made with ♥ in Atlanta.</div>
</footer>

  </body>
</html>
